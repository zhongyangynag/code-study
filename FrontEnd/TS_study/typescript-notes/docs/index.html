<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>typescript</title>
	<meta name="description" content="Documentation for typescript">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">typescript</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>typescript</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#typescript" id="typescript" style="color: inherit; text-decoration: none;">
					<h2>TypeScript</h2>
				</a>
				<blockquote>
					<p>参考</p>
					<p><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解TypeScript</a></p>
					<p><a href="https://ts.xcatliu.com/">TypeScript入门教程</a></p>
					<p><a href="http://www.semlinker.com/ts-comprehensive-tutorial/#%E4%B8%80%E3%80%81TypeScript-%E6%98%AF%E4%BB%80%E4%B9%88">了不起的 TypeScript 入门教程</a></p>
					<p><a href="https://ts.xcatliu.com/engineering/lint.html">ts代码检测</a></p>
					<p><a href="https://jkchao.github.io/typescript-book-chinese/typings/migrating.html#%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BB%A3%E7%A0%81">从javascript迁移</a></p>
				</blockquote>
				<ul>
					<li>1.初始化ts配置，生成tsconfig.json文件。<code>tsc --init</code>。 </li>
					<li>2.使用node运行ts文件，安装<code>ts-node</code>。</li>
					<li>3.<code>tsc</code> 命令增加参数后 tsconfig.json 配置文件会失效。</li>
					<li>4.<code>typedoc</code>库，可以生产typescript文档，命令<code>typedoc --out docs src</code>。</li>
				</ul>
				<a href="#原始数据类型" id="原始数据类型" style="color: inherit; text-decoration: none;">
					<h2>原始数据类型</h2>
				</a>
				<pre><code class="language-ts"><span class="hljs-comment">// boolean number string undefined null</span>
<span class="hljs-keyword">let</span> <span class="hljs-built_in">boolean</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">let</span> <span class="hljs-built_in">number</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> <span class="hljs-built_in">string</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;string&quot;</span>;
<span class="hljs-keyword">let</span> undefinedData: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">let</span> nullData: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</code></pre>
				<a href="#any" id="any" style="color: inherit; text-decoration: none;">
					<h2>any</h2>
				</a>
				<ul>
					<li>为声明的变量默认为<code>any</code>类型</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-comment">// any 任意值</span>
<span class="hljs-comment">// 默认any 类型</span>
<span class="hljs-keyword">let</span> a ;
<span class="hljs-keyword">let</span> anyThing: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>;
anyThing = <span class="hljs-number">5</span>;
anyThing = <span class="hljs-string">&quot;abc&quot;</span>;
anyThing.setName(<span class="hljs-string">&#x27;Jerry&#x27;</span>);
anyThing.setName(<span class="hljs-string">&#x27;Jerry&#x27;</span>).sayHello();
anyThing.myName.setFirstName(<span class="hljs-string">&#x27;Cat&#x27;</span>);</code></pre>
				<a href="#推论类型" id="推论类型" style="color: inherit; text-decoration: none;">
					<h2>推论类型</h2>
				</a>
				<pre><code class="language-ts"><span class="hljs-comment">//  推论类型</span>
<span class="hljs-keyword">let</span> num7 = <span class="hljs-string">&quot;seven&quot;</span>;
<span class="hljs-comment">// 不能将类型“number”分配给类型“string”。ts(2322)</span>
<span class="hljs-comment">// num7 = 7;</span>
<span class="hljs-comment">// 等价于 let num7 : string = &quot;seven&quot;;</span></code></pre>
				<a href="#联合类型" id="联合类型" style="color: inherit; text-decoration: none;">
					<h2>联合类型</h2>
				</a>
				<ul>
					<li>联合类型（Union Types）表示取值可以为多种类型中的一种。</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-comment">//  联合类型</span>
<span class="hljs-keyword">type</span> des = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">let</span> description: des = <span class="hljs-string">&quot;desc&quot;</span>;
description = <span class="hljs-number">123</span>;

<span class="hljs-keyword">let</span> a: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span> = <span class="hljs-number">1</span>;
a = <span class="hljs-literal">false</span>;</code></pre>
				<a href="#对象类型接口" id="对象类型接口" style="color: inherit; text-decoration: none;">
					<h2>对象类型——接口</h2>
				</a>
				<ul>
					<li>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</li>
					<li>接口是 TypeScript 的一个核心知识，它能合并众多类型声明至一个类型声明</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-comment">// interface</span>
<span class="hljs-comment">// 接口定义函数</span>
<span class="hljs-keyword">interface</span> fun {
  (): <span class="hljs-built_in">any</span>
}

<span class="hljs-keyword">interface</span> IData {
  <span class="hljs-comment">// 只读属性</span>
  <span class="hljs-keyword">readonly</span> id: <span class="hljs-built_in">number</span>,
  <span class="hljs-comment">// 基本类型属性</span>
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-comment">// 可有可无属性</span>
  description?: <span class="hljs-built_in">string</span>,
  <span class="hljs-comment">// 函数</span>
  toString(age?: <span class="hljs-built_in">number</span>, name?: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>,
  <span class="hljs-comment">// 引用 fun</span>
  <span class="hljs-attr">getAge</span>: fun
}

<span class="hljs-comment">// 定义任意属性的接口</span>
<span class="hljs-keyword">interface</span> IProps {
  [name: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>
}

<span class="hljs-keyword">const</span> data: IData = {
  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;data&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,
  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age, <span class="hljs-built_in">this</span>.name)
  },
  <span class="hljs-function"><span class="hljs-title">getAge</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;
  }
}

data.toString();

<span class="hljs-keyword">const</span> props: IProps = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;p&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">data</span>: data,
  <span class="hljs-attr">getAge</span>: data.getAge.bind(data)
}
props.data.toString();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;props.getAge(): &#x27;</span>, props.getAge());</code></pre>
				<a href="#数组的类型" id="数组的类型" style="color: inherit; text-decoration: none;">
					<h2>数组的类型</h2>
				</a>
				<ul>
					<li>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-comment">// 基础用法</span>
<span class="hljs-keyword">const</span> arr: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-comment">// 泛型</span>
<span class="hljs-keyword">const</span> arrString: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>];

<span class="hljs-comment">// 接口表示</span>
<span class="hljs-keyword">interface</span> IArrType {
  <span class="hljs-comment">// 下标 number 值 是联合类型 number | string</span>
  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>,
}

<span class="hljs-keyword">const</span> arrInterface: IArrType = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>]

<span class="hljs-comment">// 类数组</span>
<span class="hljs-keyword">interface</span> ILikeArrType {
  [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">any</span>,
  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-attr">callee</span>: <span class="hljs-built_in">Function</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">...item: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;</span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;item: &#x27;</span>, item);
  <span class="hljs-keyword">let</span> arg: ILikeArrType = <span class="hljs-built_in">arguments</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arg: &#x27;</span>, arg);
}

fn(<span class="hljs-number">1</span>, { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }, <span class="hljs-string">&#x27;test&#x27;</span>)
</code></pre>
				<a href="#函数类型" id="函数类型" style="color: inherit; text-decoration: none;">
					<h2>函数类型</h2>
				</a>
				<ul>
					<li>注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-comment">//  函数类型</span>

<span class="hljs-comment">// 普通返回值类型设置</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fn1&#x27;</span>)
}

fn1()

<span class="hljs-comment">// 参数设置</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;add(1,2): &#x27;</span>, add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));

<span class="hljs-comment">// 可选参数</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">joinStr</span>(<span class="hljs-params">str1: <span class="hljs-built_in">string</span>, str2?: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">return</span> str1 + str2;
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;joinStr(&quot;123&quot;): &#x27;</span>, joinStr(<span class="hljs-string">&#x27;123&#x27;</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;joinStr(&quot;123&quot;,&quot;456&quot;): &#x27;</span>, joinStr(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;456&quot;</span>));

<span class="hljs-comment">// 默认参数</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultParams</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;default&quot;</span>, num: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span></span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;defaultParams: str&#x27;</span>, str);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;defaultParams: num&#x27;</span>, num);
}

defaultParams();

<span class="hljs-comment">// 函数表达式</span>

<span class="hljs-comment">// 注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。</span>
<span class="hljs-comment">// 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</span>
<span class="hljs-keyword">const</span> myFn: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">return</span> x + y;
}


<span class="hljs-comment">//  接口定义函数形状</span>
<span class="hljs-keyword">interface</span> IFn {
  (x: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>,
  name?: <span class="hljs-built_in">string</span>
}
<span class="hljs-comment">// es6的箭头函数实现</span>
<span class="hljs-keyword">const</span> myTest: IFn = (x: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> { <span class="hljs-keyword">return</span> x + y }
<span class="hljs-keyword">let</span> myIFn: IFn;
myIFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;myIFn.name: &#x27;</span>, myIFn.name);
  <span class="hljs-keyword">return</span> x + y
}

myIFn(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);


<span class="hljs-comment">//  剩余参数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">res</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, ...list: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;</span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a: &#x27;</span>, a);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;list: &#x27;</span>, list);
}

<span class="hljs-comment">// 类型“boolean”的参数不能赋给类型“string | number”的参数。ts(2345)</span>
<span class="hljs-comment">// res(&#x27;1&#x27;, 2, 3, &#x27;4&#x27;, true)</span>
res(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>)


<span class="hljs-comment">// 重载</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);
  }
}
</code></pre>
				<a href="#可实例化" id="可实例化" style="color: inherit; text-decoration: none;">
					<h3>可实例化</h3>
				</a>
				<ul>
					<li>可实例化仅仅是可调用的一种特殊情况，它使用 new 作为前缀。它意味着你需要使用 new 关键字去调用它：</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-keyword">interface</span> CallMeWithNewToGetString {
  <span class="hljs-keyword">new</span> (): <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> Foo: CallMeWithNewToGetString;
<span class="hljs-keyword">const</span> bar = <span class="hljs-keyword">new</span> Foo(); <span class="hljs-comment">// bar 被推断为 string 类型</span></code></pre>
				<a href="#断言类型" id="断言类型" style="color: inherit; text-decoration: none;">
					<h2>断言类型</h2>
				</a>
				<ul>
					<li> 类型断言（Type Assertion）可以用来手动指定一个值的类型。</li>
				</ul>
				<blockquote>
					<p>TypeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」。</p>
					<p>TypeScript 类型断言用来告诉编译器你比它更了解这个类型，并且它不应该再发出错误。</p>
				</blockquote>
				<pre><code class="language-ts"><span class="hljs-comment">// 语法</span>
<span class="hljs-comment">// 值 as 类型 或 &lt;类型&gt;值</span>

<span class="hljs-comment">// 类型断言的常见用途有以下几种：</span>
<span class="hljs-comment">// 将一个联合类型断言为其中一个类型</span>
<span class="hljs-comment">// 之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法：</span>
<span class="hljs-comment">// 而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如下例</span>

<span class="hljs-keyword">interface</span> ICat {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,
  run(): <span class="hljs-built_in">void</span>
}

<span class="hljs-keyword">interface</span> IFish {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,
  swim(): <span class="hljs-built_in">void</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFish</span>(<span class="hljs-params">animal: ICat | IFish</span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-comment">// 类型“ICat | IFish”上不存在属性“swim”。</span>
  <span class="hljs-comment">// 类型“ICat”上不存在属性“swim”。</span>
  <span class="hljs-comment">// if (typeof animal.swim == &#x27;function&#x27;) {</span>
  <span class="hljs-comment">//   return true;</span>
  <span class="hljs-comment">// }</span>

  <span class="hljs-comment">// 使用断言 </span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> (animal <span class="hljs-keyword">as</span> IFish).swim == <span class="hljs-string">&#x27;function&#x27;</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-comment">// 将一个父类断言为更加具体的子类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
  <span class="hljs-attr">statusCode</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">200</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isApiError</span>(<span class="hljs-params">error: <span class="hljs-built_in">Error</span></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> (error <span class="hljs-keyword">as</span> ApiError).code === <span class="hljs-string">&#x27;number&#x27;</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-comment">// 将任何一个类型断言为 any</span>


<span class="hljs-keyword">const</span> foo: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;
<span class="hljs-comment">// foo.length = 1;</span>
<span class="hljs-comment">// 类型“number”上不存在属性“length”。ts(2339)</span>

<span class="hljs-comment">// window.foo = 1;</span>
<span class="hljs-comment">// 类型“Window &amp; typeof globalThis”上不存在属性“foo”。ts(2339)</span>
(<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).foo = <span class="hljs-number">1</span>;

<span class="hljs-comment">// 将 any 断言为一个具体的类型</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCacheData</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">any</span> </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).cache[key];
}
<span class="hljs-keyword">interface</span> Cat {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  run(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">const</span> tom = getCacheData(<span class="hljs-string">&#x27;tom&#x27;</span>) <span class="hljs-keyword">as</span> Cat;
tom.run();
</code></pre>
				<a href="#声明文件" id="声明文件" style="color: inherit; text-decoration: none;">
					<h2>声明文件</h2>
				</a>
				<ul>
					<li>declare var 声明全局变量</li>
					<li>declare function 声明全局方法</li>
					<li>declare class 声明全局类</li>
					<li>declare enum 声明全局枚举类型</li>
					<li>declare namespace 声明（含有子属性的）全局对象</li>
					<li>interface 和 type 声明全局类型</li>
					<li>export 导出变量</li>
					<li>export namespace 导出（含有子属性的）对象</li>
					<li>export default ES6 默认导出</li>
					<li>export = commonjs 导出模块</li>
					<li>export as namespace UMD 库声明全局变量</li>
					<li>declare global 扩展全局变量</li>
					<li>declare module 扩展模块</li>
					<li>/// <reference /> 三斜线指令</li>
				</ul>
				<blockquote>
					<p><a href="https://ts.xcatliu.com/basics/declaration-files.html">TypeScript入门教程——声明文件</a></p>
				</blockquote>
				<pre><code class="language-ts">
<span class="hljs-comment">// 声明语句</span>
<span class="hljs-comment">// 声明全面变量 JQuery 的描述，一个方法 接收string参数 返回 any </span>
<span class="hljs-comment">// declare var JQuery: (selector: string) =&gt; any;</span>
<span class="hljs-comment">// 找不到名称“JQuery”。ts(2304)</span>
<span class="hljs-keyword">const</span> eleFoo = JQuery(<span class="hljs-string">&#x27;foo&#x27;</span>);

<span class="hljs-comment">// 声明文件</span>
<span class="hljs-comment">// 通常我们会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件：</span>
<span class="hljs-comment">// 一般来说，ts 会解析项目中所有的 *.ts 文件，当然也包含以 .d.ts 结尾的文件。</span>
<span class="hljs-comment">// 所以当我们将 jQuery.d.ts 放到项目中时，其他所有 *.ts 文件就都可以获得 jQuery 的类型定义了。</span>

<span class="hljs-comment">// 第三方声明文件</span>
<span class="hljs-comment">// 我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件。</span>
<span class="hljs-comment">// @types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：</span>
<span class="hljs-comment">// npm install @types/jquery --save-dev</span>

<span class="hljs-comment">// Animal.t.ds 声明后不需要通过 import 引入即可使用</span>
<span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;mimi&#x27;</span>, <span class="hljs-number">2</span>);


<span class="hljs-comment">// 三斜杠</span>

<span class="hljs-comment">// 拆分声明文件</span>
<span class="hljs-comment">// 当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 jQuery 的声明文件就是这样的：</span>

<span class="hljs-comment">// node_modules/@types/jquery/index.d.ts</span>

<span class="hljs-comment">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span>
<span class="hljs-comment">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span>
<span class="hljs-comment">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span>
<span class="hljs-comment">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span>
<span class="hljs-comment">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span>

<span class="hljs-keyword">export</span> = jQuery;
<span class="hljs-comment">// 其中用到了 types 和 path 两种不同的指令。它们的区别是：types 用于声明对另一个库的依赖，而 path 用于声明对另一个文件的依赖。</span>
<span class="hljs-comment">// 上例中，sizzle 是与 jquery 平行的另一个库，所以需要使用 types=&quot;sizzle&quot; 来声明对它的依赖。</span>
<span class="hljs-comment">// 而其他的三斜线指令就是将 jquery 的声明拆分到不同的文件中了，然后在这个入口文件中使用 path=&quot;foo&quot; 将它们一一引入。</span>
</code></pre>
				<a href="#内置对象" id="内置对象" style="color: inherit; text-decoration: none;">
					<h2>内置对象</h2>
				</a>
				<ul>
					<li><p>ECMAScript 标准提供的内置对象有：</p>
						<ul>
							<li>Boolean、Error、Date、RegExp 等。</li>
						</ul>
					</li>
					<li><p>DOM 和 BOM 提供的内置对象有：</p>
						<ul>
							<li>Document、HTMLElement、Event、NodeList 等。</li>
						</ul>
					</li>
					<li><p>用 TypeScript 写 Node.js</p>
						<ul>
							<li>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：<blockquote>
									<p>npm install @types/node --save-dev</p>
								</blockquote>
							</li>
						</ul>
					</li>
				</ul>
				<a href="#类型别名与字符串字面量类型" id="类型别名与字符串字面量类型" style="color: inherit; text-decoration: none;">
					<h2>类型别名与字符串字面量类型</h2>
				</a>
				<ul>
					<li>类型别名用来给一个类型起个新名字，使用<code>type</code>创建。</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-keyword">type</span> name = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;

</code></pre>
				<ul>
					<li>字符串字面量类型同样使用<code>type</code>创建。</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-keyword">type</span> EventName = <span class="hljs-string">&#x27;click&#x27;</span> | <span class="hljs-string">&#x27;change&#x27;</span> | <span class="hljs-string">&#x27;scroll&#x27;</span> | <span class="hljs-string">&#x27;select&#x27;</span> ;

<span class="hljs-comment">// event 必须为 EventName 定义的几种类型</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEvent</span>(<span class="hljs-params">event:EventName</span>)</span>{

}</code></pre>
				<a href="#元组" id="元组" style="color: inherit; text-decoration: none;">
					<h2>元组</h2>
				</a>
				<ul>
					<li>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。</li>
					<li>元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。</li>
					<li>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-keyword">let</span> tom: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">25</span>];
tom.push(<span class="hljs-string">&#x27;male&#x27;</span>);
tom.push(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// Argument of type &#x27;true&#x27; is not assignable to parameter of type &#x27;string | number&#x27;.</span></code></pre>
				<a href="#枚举" id="枚举" style="color: inherit; text-decoration: none;">
					<h2>枚举</h2>
				</a>
				<ul>
					<li><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Enums.html">枚举参考</a></li>
				</ul>
				<a href="#类" id="类" style="color: inherit; text-decoration: none;">
					<h2>类</h2>
				</a>
				<ul>
					<li><a href="https://ts.xcatliu.com/advanced/class.htmlhttps://ts.xcatliu.com/advanced/class.html">类</a><blockquote>
							<p>参考java</p>
						</blockquote>
					</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }
  sayHi(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`My name is <span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>`</span>;
  }
}

<span class="hljs-keyword">let</span> a: Animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);
<span class="hljs-built_in">console</span>.log(a.sayHi()); <span class="hljs-comment">// My name is Jack</span></code></pre>
				<a href="#类与接口" id="类与接口" style="color: inherit; text-decoration: none;">
					<h2>类与接口</h2>
				</a>
				<ul>
					<li><a href="https://ts.xcatliu.com/advanced/class-and-interfaces.html">类与接口</a><blockquote>
							<p>参考java</p>
						</blockquote>
					</li>
				</ul>
				<a href="#泛型" id="泛型" style="color: inherit; text-decoration: none;">
					<h2>泛型</h2>
				</a>
				<ul>
					<li>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-comment">//  未使用泛型：any类型太宽泛</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span>[] </span>{
  <span class="hljs-keyword">const</span> res: <span class="hljs-built_in">any</span>[] = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    res[i] = value;
  }
  <span class="hljs-keyword">return</span> res;
}

createArray(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>);

<span class="hljs-comment">// 使用泛型：通过使用泛型，将类型传入管理类型范围</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray1</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
  <span class="hljs-keyword">const</span> res: <span class="hljs-built_in">Array</span>&lt;T&gt; = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    res[i] = value;
  }
  <span class="hljs-keyword">return</span> res;
}

createArray1&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>);
createArray1(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>);

<span class="hljs-comment">// 定义泛型的时候，可以一次定义多个类型参数：</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">tuple: [T, U]</span>): [<span class="hljs-title">U</span>, <span class="hljs-title">T</span>] </span>{
  <span class="hljs-keyword">return</span> [tuple[<span class="hljs-number">1</span>], tuple[<span class="hljs-number">0</span>]];
}

swap([<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;seven&#x27;</span>]); <span class="hljs-comment">// [&#x27;seven&#x27;, 7]</span>

<span class="hljs-comment">// 泛型约束 ： 泛型的上下限</span>

<span class="hljs-keyword">interface</span> Lengthwise {
  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// 设置上限Lengthwise，泛型类型T必须是Lengthwise的子类</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lengthwise</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>{
  <span class="hljs-built_in">console</span>.log(arg.length);
  <span class="hljs-keyword">return</span> arg;
}


<span class="hljs-comment">// 泛型接口</span>

<span class="hljs-keyword">interface</span> CreateArrayFunc {
  &lt;T&gt;(length: <span class="hljs-built_in">number</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-built_in">Array</span>&lt;T&gt;;
}

<span class="hljs-keyword">let</span> createArray2: CreateArrayFunc;
createArray2 = <span class="hljs-function"><span class="hljs-keyword">function</span> &lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
  <span class="hljs-keyword">let</span> result: T[] = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    result[i] = value;
  }
  <span class="hljs-keyword">return</span> result;
}

createArray2(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span>

<span class="hljs-comment">// </span>
<span class="hljs-keyword">interface</span> CreateArrayFunc1&lt;T&gt; {
  (length: <span class="hljs-built_in">number</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-built_in">Array</span>&lt;T&gt;;
}

<span class="hljs-keyword">let</span> createArray3: CreateArrayFunc1&lt;<span class="hljs-built_in">any</span>&gt;;
createArray3 = <span class="hljs-function"><span class="hljs-keyword">function</span> &lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
  <span class="hljs-keyword">let</span> result: T[] = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    result[i] = value;
  }
  <span class="hljs-keyword">return</span> result;
}

createArray3(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span>


<span class="hljs-comment">// 泛型类</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericNumber</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
  <span class="hljs-attr">zeroValue</span>: T | <span class="hljs-literal">undefined</span>;
  add: (<span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T) | <span class="hljs-literal">undefined</span>;
}

<span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> GenericNumber&lt;<span class="hljs-built_in">number</span>&gt;();
myGenericNumber.zeroValue = <span class="hljs-number">0</span>;
myGenericNumber.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>{ <span class="hljs-keyword">return</span> x + y; };</code></pre>
				<a href="#声明合并" id="声明合并" style="color: inherit; text-decoration: none;">
					<h2>声明合并</h2>
				</a>
				<ul>
					<li>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：</li>
					<li><a href="https://ts.xcatliu.com/advanced/declaration-merging.html">接口合并</a></li>
				</ul>
				<ol>
					<li>函数合并</li>
				</ol>
				<pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) {
        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);
    }
}</code></pre>
				<ol start="2">
					<li>接口合并</li>
				</ol>
				<pre><code class="language-ts"><span class="hljs-keyword">interface</span> Alarm {
    <span class="hljs-attr">price</span>: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">interface</span> Alarm {
    <span class="hljs-attr">weight</span>: <span class="hljs-built_in">number</span>;
}
<span class="hljs-comment">// 相当于：</span>
<span class="hljs-keyword">interface</span> Alarm {
    <span class="hljs-attr">price</span>: <span class="hljs-built_in">number</span>;
    weight: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> Alarm {
    <span class="hljs-attr">price</span>: <span class="hljs-built_in">number</span>;
    alert(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> Alarm {
    <span class="hljs-attr">weight</span>: <span class="hljs-built_in">number</span>;
    alert(s: <span class="hljs-built_in">string</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;
}
<span class="hljs-comment">// 相当于：</span>
<span class="hljs-keyword">interface</span> Alarm {
    <span class="hljs-attr">price</span>: <span class="hljs-built_in">number</span>;
    weight: <span class="hljs-built_in">number</span>;
    alert(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;
    alert(s: <span class="hljs-built_in">string</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;
}</code></pre>
				<a href="#全局模块与文件模块" id="全局模块与文件模块" style="color: inherit; text-decoration: none;">
					<h2>全局模块与文件模块</h2>
				</a>
				<ul>
					<li>默认TypeScript中声明的代码都处于全局命名空间中。使用全局变量空间是危险的，因为它会与文件内的代码命名冲突。</li>
					<li>文件模块避免全局污染。</li>
					<li>推荐模块使用<code>module: commonjs</code>。</li>
					<li>模块语法推荐使用ES模块语法。</li>
				</ul>
				<p>全局模块</p>
				<pre><code class="language-ts"><span class="hljs-comment">// foo.ts</span>
<span class="hljs-keyword">const</span> foo1 : <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;foo&quot;</span>;

<span class="hljs-comment">// bar.ts 可以使用foo1</span>
<span class="hljs-keyword">let</span> bar: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;
bar = foo1;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bar: &#x27;</span>, bar);</code></pre>
				<p>局部模块</p>
				<pre><code class="language-ts"><span class="hljs-comment">// foo.ts</span>
<span class="hljs-keyword">let</span> foo1: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;
<span class="hljs-keyword">export</span> { foo1 };


<span class="hljs-comment">// bar.ts</span>
<span class="hljs-keyword">let</span> bar: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;

<span class="hljs-comment">// 无法直接使用全局变量foo1</span>
<span class="hljs-comment">// 找不到名称“foo1”。你是否指的是“foo”?ts(2552)</span>
<span class="hljs-comment">// assertType.ts(54, 7): 在此处声明了 &quot;foo&quot;</span>
bar = foo1;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bar: &#x27;</span>, bar);


<span class="hljs-comment">// bar.ts 使用foo1</span>
<span class="hljs-comment">// 方法1</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
<span class="hljs-keyword">let</span> bar: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;
bar = foo.foo1;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bar: &#x27;</span>, bar);

<span class="hljs-comment">// 方法2</span>
<span class="hljs-keyword">import</span> { foo1 } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>
<span class="hljs-keyword">let</span> bar: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;
bar = foo1;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bar: &#x27;</span>, bar);

<span class="hljs-comment">// 方法3</span>
<span class="hljs-keyword">import</span> { foo1 <span class="hljs-keyword">as</span> foo } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo&#x27;</span>;
<span class="hljs-keyword">let</span> bar: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;
bar = foo;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bar: &#x27;</span>, bar);</code></pre>
				<a href="#交叉类型" id="交叉类型" style="color: inherit; text-decoration: none;">
					<h2>交叉类型</h2>
				</a>
				<ul>
					<li>在 JavaScript 中， <code>extend</code> 是一种非常常见的模式，在这种模式中，你可以从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。交叉类型可以让你安全的使用此种模式</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-comment">// 返回 T &amp; U  合并的类型</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>, <span class="hljs-title">U</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params">first: T, second: U</span>): <span class="hljs-title">T</span> &amp; <span class="hljs-title">U</span> </span>{
  <span class="hljs-keyword">const</span> result = &lt;T &amp; U&gt;{};
  for (let id in first) {
    (&lt;T&gt;result)[id] = first[id];
  }
  for (let id in second) {
    if (!result.hasOwnProperty(id)) {
      (&lt;U&gt;result)[id] = second[id];
    }
  }

  return result;
}

// 返回 x = {a:&#x27;hello&#x27;,b:42}
const x = extend({ a: &#x27;hello&#x27; }, { b: 42 });

// 现在 x 拥有了 a 属性与 b 属性
const a = x.a;
const b = x.b;</code></pre>
				<a href="#有静态方法的枚举" id="有静态方法的枚举" style="color: inherit; text-decoration: none;">
					<h2>有静态方法的枚举</h2>
				</a>
				<ul>
					<li>你可以使用 enum + namespace 的声明的方式向枚举类型添加静态方法。如下例所示，我们将静态成员 isBusinessDay 添加到枚举上</li>
				</ul>
				<pre><code class="language-ts"><span class="hljs-built_in">enum</span> Weekday {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
}

<span class="hljs-keyword">namespace</span> Weekday {
    <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBusinessDay</span>(<span class="hljs-params">day: Weekday</span>) </span>{
        <span class="hljs-keyword">switch</span> (day) {
            <span class="hljs-keyword">case</span> Weekday.Saturday:
            <span class="hljs-keyword">case</span> Weekday.Sunday:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    }
}

<span class="hljs-keyword">const</span> mon = Weekday.Monday;
<span class="hljs-keyword">const</span> sun = Weekday.Sunday;

<span class="hljs-built_in">console</span>.log(Weekday.isBusinessDay(mon)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(Weekday.isBusinessDay(sun));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Weekday.Friday: &#x27;</span>, Weekday.Friday);</code></pre>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_arraytype_.html">&quot;array<wbr>Type&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_asserttype_.html">&quot;assert<wbr>Type&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_declarefile_.html">&quot;declare<wbr>File&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_functiontype_.html">&quot;function<wbr>Type&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_generics_.html">&quot;generics&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_hello_.html">&quot;hello&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_interface_.html">&quot;interface&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_module_bar_.html">&quot;module/bar&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_module_foo_.html">&quot;module/foo&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_object_.html">&quot;object&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_primitivetype_.html">&quot;primitive<wbr>Type&quot;</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
</body>
</html>